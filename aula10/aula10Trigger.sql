CREATE TABLE IF NOT EXISTS a10.time (
id INTEGER PRIMARY KEY,
nome VARCHAR(50)
);
CREATE TABLE IF NOT EXISTS a10.partida (
id INTEGER PRIMARY KEY,
time_1 INTEGER,
time_2 INTEGER,
time_1_gols INTEGER,
time_2_gols INTEGER,
FOREIGN KEY(time_1) REFERENCES a10.time(id),
FOREIGN KEY(time_2) REFERENCES a10.time(id)
);
INSERT INTO a10.time(id, nome) VALUES
(1,'CORINTHIANS'),
(2,'SÃO PAULO'),
(3,'CRUZEIRO'),
(4,'ATLETICO MINEIRO'),
(5,'PALMEIRAS');
INSERT INTO a10.partida(id, time_1, time_2, time_1_gols, time_2_gols)
VALUES
(1,4,1,0,4),
(2,3,2,0,1),
(3,1,3,3,0),
(4,3,4,0,1),
(5,1,2,0,0),
(6,2,4,2,2),
(7,1,5,1,2),
(8,5,2,1,2);

SELECT * FROM a10.PARTIDA;

-- AS TRIGGER SÃO GATILHOS AUTIMÁTICOS QUE SÃO EXECUTADOS ANTES OU DEPOIS DE UMA OPERAÇÃO DE INSERT, UPDATE OU DELETE
-- AS TRIGGER SÃO MUITO UTILIZADAS PARA GARANTIR A INTEGRIDADE DOS DADOS
-- QUANDO AS TRIGGER SÃO NECESSÁRIAS?
-- 1- QUANDO É NECESSÁRIO GARANTIR A INTEGUIDADE DOS DADOS
-- 2- QUANDO É NECESSÁRIO GARANTIR A CONSISTENCIA DOS DADOS
-- 3 - PARA VALIDAR REGRAS DE NEGÓCIOS ANTES DE INSERIR, ATUALIZAR OU DELETAR DADOS
-- 4 - PARA AUTOMATIZAR TAREFAS QUE DEVME SER EXECUTADAS

-- EXEMPLO DE TRIGGER QUE NÃO PERMITE QUE UM TIME SEJA DELETADO SE ELE TIVER JOGOS CADASTRADOS

-- PARA MOSTRAR COMO ACONTECE NAS AUDITORIAS, VOU FAZER UMA TABELA QUE REGISTRA OS EVENTOSDAS OUTRAS
CREATE TABLE A10.LOG_PARTIDA(
    ID SERIAL PRIMARY KEY,
    PARTIDA_ID INTEGER,
    ACAO VARCHAR(20),
    DATA TIMESTAMP DEFAULT CURRENT_TIMESTAMP -- É PARA PEGAR A DATA E HORA ATUAL
)

-- CRIAÇÃO DE TRIGGER COM SINTAXE POSTGRES
CREATE OR REPLACE FUNCTION LOG_PARTIDA_INSERT() RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO A10.LOG_PARTIDA(PARTIDA_ID, ACAO) VALUES (NEW.ID, 'INSERT'); -- ESSE NEW.ID PEGA O ID DA PARTIDA QUE VAI SER REFERENCIADA NA CRIAÇÃO DO TRIGGER
    RETURN NEW; -- PARA GARANTUR QUE A OPERAÇÃO CONTINUE NORMALMENTE E 
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER LOG_PARTIDA_INSERT
AFTER INSERT ON A10.partida
FOR EACH ROW
EXECUTE FUNCTION LOG_PARTIDA_INSERT();

INSERT INTO A10.partida VALUES(10,2,2,1,9);
SELECT * FROM A10.LOG_PARTIDA;

-- CRIANDO TRIGGER DE RESTIÇÃO

CREATE OR REPLACE FUNCTION A10.INSERT_PARTIDA()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.TIME_1 = NEW.TIME_2 THEN
        RAISE EXCEPTION 'Não é permitido jogos entre o mesmo time';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER INSERT_PARTIDA
BEFORE INSERT ON A10.PARTIDA
FOR EACH ROW
EXECUTE FUNCTION A10.INSERT_PARTIDA();

-- INSERT INTO A10.partida VALUES (10,1,1,1,9);

-- O INSTEAD OF NÃO É SUPORTADO PELO MYSQL PORQUE ELE NÃO TEM O SUPORTE PARA TRIGGER DE VISÃO
-- O INSTRAD OF É UTILIZADO PARA FAZER TRIGGER EM VISÕES
-- NO POSTGRES
-- O INSTEAD OF É UTILIZADO PARA FAZER TRIGGER EM VISÕES

-- EXEMPLO
CREATE VIEW A10.PARTIDA_V AS
SELECT ID, TIME_1 AS "Time A",TIME_2 as "Time B", TIME_1_GOLS as "Gols Time A",TIME_2_GOLS as "Gols Time B" FROM A10.PARTIDA;

-- AGORA QUEREMOS PERMITIR INSERÇÕES NA PARTIDA_V, MAS OS DADOS REAIS DEVEM SER ARMAZENADOS NA TABELA PARTIDA, PARA ISSO USAMOS O INSTEAD OF

CREATE OR REPLACE FUNCTION A10.INSERT_PARTIDA_V()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO A10.PARTIDA VALUES (NEW.ID, NEW."Time A", NEW."Time B", NEW."Gols Time A", NEW."Gols Time B");
    RETURN NULL;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER INSERT_PARTIDA_V
INSTEAD OF INSERT ON A10.PARTIDA_V -- AQUI A GENTE ESTÁ DIZENDO QUE A TRIGGER VAI SER EXECUTADA NO LUGAR DE UMA VISÃO DE INSERÇÃO
FOR EACH ROW
EXECUTE FUNCTION A10.INSERT_PARTIDA_V();

INSERT INTO A10.partida_v(id, "Time A", "Time B", "Gols Time A", "Gols Time B")
VALUES
(12,1,4,0,10);

SELECT * FROM A10.partida_V;
--testasdasdsadaasda